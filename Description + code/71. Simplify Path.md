## 题目地址：[Simplify Path](https://leetcode.com/problems/simplify-path/)
---
## 题目简介：
以Unix风格给出一个文件的绝对路径，需要对齐进行简化。或者换句话说，将其转换为规范路径。   

在Unix风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径。    

请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。   

> 示例 1：  输入："/home/"  输出："/home"  解释：注意，最后一个目录名后面没有斜杠。    
> 示例 2：  输入："/../"  输出："/"  解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。    
> 示例 3：  输入："/home//foo/"  输出："/home/foo"  解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。    
> 示例 4：  输入："/a/./b/../../c/"  输出："/c"    
> 示例 5：  输入："/a/../../b/../c//.//"  输出："/c"    
> 示例 6：  输入："/a//b////c/d//././/.."  输出："/a/b/c"     

---
## 题目解析：   
总的可以分为以下几种情况需要考虑：   
+ 当前字符是不是"/"，是"/"情况下是不是连续的；   
+ 当前字符；是不是"."，是"."情况下是不是两个"."；   
+ 其他字符；   

解法1：可以单个的字符考虑，但是需要考虑的情况较多，这里不做介绍。     
解法2：观察到在有效的"/"之间存在着一个字符串，这个字符串可能是"."、".."和其他的正常字符串，只要处理好这几种字符串即可。需要注意的是，当出现".."是，需要对原来的路径进行一个类似出栈的操作，所以这里使用栈。
> C++：

```c++
class Solution {
public:
    string simplifyPath(string path) {
        stack<string> ans;
        for (int i = 0; i < path.length(); i++)
        {
            while(i < path.size() && '/' == path[i])
                i++;
            string tmp = "";
            while(i < path.size() && path[i] != '/')
                tmp += path[i++];
            if(tmp == ".." && !ans.empty())
                ans.pop();
            else if(tmp != "" && tmp != "." && tmp != "..")
                ans.push(tmp);
        }
        if(ans.empty())
            return "/";
        string res = "";
        while(!ans.empty())
        {
            res = "/" + ans.top() + res;
            ans.pop();
        }
         return res;
    }
};
```
